<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workforce Management & FTE Calculator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .form-section {
            background: #f8fafc;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .form-section h2 {
            color: #1e293b;
            margin-bottom: 20px;
            font-size: 1.4rem;
            border-bottom: 2px solid #4f46e5;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }

        .form-group select,
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        .form-group select:focus,
        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .time-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 12px;
        }

        .data-table th,
        .data-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: top;
        }

        .data-table th {
            background: #f1f5f9;
            font-weight: 600;
            color: #374151;
            font-size: 11px;
        }

        .data-table tr:hover {
            background: #f8fafc;
        }

        .reports-section {
            grid-column: 1 / -1;
            background: #f8fafc;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            margin-top: 20px;
        }

        .report-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .report-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 4px solid #4f46e5;
            transition: transform 0.3s ease;
        }

        .report-card:hover {
            transform: translateY(-2px);
        }

        .report-card h3 {
            color: #1e293b;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .report-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4f46e5;
        }

        .report-card .label {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        /*
         * Button used for editing existing time entries. Styled similarly to
         * the delete button but with a distinct color to indicate a different
         * action. A small margin is added on the right to separate it from
         * adjacent buttons.
         */
        .edit-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
        }

        .edit-btn:hover {
            background: #059669;
        }

        .delete-btn:hover {
            background: #dc2626;
        }

        .entries-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .alert {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }

        .alert-success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .alert-error {
            background: #fef2f2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .time-group {
                grid-template-columns: 1fr;
            }

            .data-table {
                font-size: 10px;
            }

            .data-table th,
            .data-table td {
                padding: 6px;
            }
        }

        /*
         * Styles for the dashboard container used to display charts.  The
         * container uses a flexible layout so charts wrap nicely on
         * smaller screens.  Each canvas is given a minimum size to
         * improve readability while remaining responsive.
         */
        .dashboard-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }

        /*
         * Styles for the dashboard menu that allows users to choose
         * which charts to generate.  The menu uses a flexible
         * horizontal layout that wraps on smaller screens.  Labels and
         * selects are spaced evenly and aligned vertically.
         */
        .dashboard-menu {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }
        .dashboard-menu label {
            margin-right: 4px;
            font-size: 0.9rem;
        }

        /*
         * Styles for the custom bar charts used in the dashboard.  Each
         * chart consists of a heading followed by rows showing a label
         * and a horizontal bar proportional to the value.  The bar
         * contains a data-value attribute so the number can be shown
         * inside the bar via a pseudo-element.
         */
        .custom-bar-chart {
            flex: 1 1 400px;
            min-width: 300px;
            width: 100%;
        }

        .custom-bar-chart h4 {
            margin-bottom: 8px;
            font-size: 1rem;
            color: #3730a3; /* deep indigo for chart titles */
        }

        .bar-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .bar-label {
            width: 40%;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 8px;
        }

        .bar {
            position: relative;
            height: 22px;
            background-color: rgba(99, 102, 241, 0.8);
            border-radius: 4px;
            flex-grow: 1;
        }

        .bar::after {
            content: attr(data-value);
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: #1f2937; /* dark slate */
        }
    </style>
    <!-- Include Chart.js for the dashboard visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Workforce Management System</h1>
            <p>Comprehensive FTE Calculator & Time Tracking Solution</p>
        </div>

        <div class="main-content">
            <!-- Data Entry Form -->
            <div class="form-section">
                <h2>📝 Employee Time Entry</h2>
                <div id="alertContainer"></div>
                
                <div class="form-group">
                    <label for="logDate">Log Date:</label>
                    <input type="date" id="logDate" required>
                </div>

                <div class="form-group">
                    <label for="employeeName">Employee Name:</label>
                    <select id="employeeName" required>
                        <option value="">Select Employee</option>
                        <option value="DR. ARLENE S. SY">DR. ARLENE S. SY</option>
                        <option value="MR. ALLEN JAY P. GONDA">MR. ALLEN JAY P. GONDA</option>
                        <option value="MR. NEIL IRVING QUERUBIN">MR. NEIL IRVING QUERUBIN</option>
                        <option value="MS. MICHELLE M. YGAR">MS. MICHELLE M. YGAR</option>
                        <option value="MR. REY V. ROLLON">MR. REY V. ROLLON</option>
                        <option value="MR. NEREO VILLAFLORES">MR. NEREO VILLAFLORES</option>
                        <option value="MS. NADIA CZARINA MAE CORTUNA">MS. NADIA CZARINA MAE CORTUNA</option>
                        <option value="MS. GENECA JANEL GENETA-HALUM">MS. GENECA JANEL GENETA-HALUM</option>
                        <option value="MS. EUNICE TADALAN-QUIBOLOY">MS. EUNICE TADALAN-QUIBOLOY</option>
                        <option value="MS. JULIE CHRISTINE BANDIOLA">MS. JULIE CHRISTINE BANDIOLA</option>
                        <option value="MS. MARIA LANY ROSE BRIONES">MS. MARIA LANY ROSE BRIONES</option>
                        <option value="MS. MARY AUBREY FINEZA">MS. MARY AUBREY FINEZA</option>
                        <option value="MR. RAFH L. MARASIGAN">MR. RAFH L. MARASIGAN</option>
                        <option value="MR. LAWRENCE EDWARD MANEJA">MR. LAWRENCE EDWARD MANEJA</option>
                        <option value="MS. AYCA P. HERNANDEZ">MS. AYCA P. HERNANDEZ</option>
                        <option value="MS.DANA TWAIN SOLANO">MS.DANA TWAIN SOLANO</option>
                        <option value="MR. KEVIN JOHN DANDOY">MR. KEVIN JOHN DANDOY</option>
                        <option value="MR. ROMMEL L. CALANO">MR. ROMMEL L. CALANO</option>
                        <option value="MR. ERMIL D. SADOL">MR. ERMIL D. SADOL</option>
                        <option value="MR. MARK RAVEN JAY G. DULAY">MR. MARK RAVEN JAY G. DULAY</option>
                        <option value="MS. LYNNE DENISE TIQUIS">MS. LYNNE DENISE TIQUIS</option>
                        <option value="ENGR. MARK JUDE GUERRERO">ENGR. MARK JUDE GUERRERO</option>
                        <option value="MR. JUN JUN ESGUERRA III">MR. JUN JUN ESGUERRA III</option>
                        <option value="MS. JEDY ARA TURGA">MS. JEDY ARA TURGA</option>
                        <option value="MS. MARY SHIELL PANGANIBAN">MS. MARY SHIELL PANGANIBAN</option>
                        <option value="MS. CAROL CALLO">MS. CAROL CALLO</option>
                        <option value="MS. ARMI A. CABITAC">MS. ARMI A. CABITAC</option>
                        <option value="MR. ALDRIN VALBUENA">MR. ALDRIN VALBUENA</option>
                        <option value="MS. MARIA MAGNA HERNANDEZ-TRIA">MS. MARIA MAGNA HERNANDEZ-TRIA</option>
                        <option value="MR. JAN LESTER O. EDJAN">MR. JAN LESTER O. EDJAN</option>
                        <option value="MR. ARDENNES ESAR">MR. ARDENNES ESAR</option>
                        <option value="MR. JAY REYES">MR. JAY REYES</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="taskDescription">Task Description:</label>
                    <textarea id="taskDescription" rows="3" placeholder="Describe the task performed..."></textarea>
                </div>

                <div class="form-group">
                    <label for="taskGroup">Task Group:</label>
                    <select id="taskGroup" required>
                        <option value="">Select Task Group</option>
                        <option value="Health Systems Development and Policy Assistance">Health Systems Development and Policy Assistance</option>
                        <option value="Service Delivery Supervision (BHS, RHU, Hospitals, Lying-in, Mobile)">Service Delivery Supervision (BHS, RHU, Hospitals, Lying-in, Mobile)</option>
                        <option value="Disease Surveillance and Outbreak Response">Disease Surveillance and Outbreak Response</option>
                        <option value="Supply Chain and Logistics Coordination">Supply Chain and Logistics Coordination</option>
                        <option value="HRH Deployment Oversight and TA">HRH Deployment Oversight and TA</option>
                        <option value="Monitoring and Evaluation / Data Validation">Monitoring and Evaluation / Data Validation</option>
                        <option value="Financial and Budgetary TA to LGUs">Financial and Budgetary TA to LGUs</option>
                        <option value="Intersectoral Engagements / Stakeholder Meetings">Intersectoral Engagements / Stakeholder Meetings</option>
                        <option value="Field Visits (Technical Supervision)">Field Visits (Technical Supervision)</option>
                        <option value="Administrative and Internal Coordination">Administrative and Internal Coordination</option>
                        <option value="Report Preparation / Documentation">Report Preparation / Documentation</option>
                        <option value="Trainings, Workshops, and Capacity Building (as Resource Person or Facilitator)">Trainings, Workshops, and Capacity Building (as Resource Person or Facilitator)</option>
                        <option value="Others (specify)">Others (specify)</option>
                    </select>
                </div>

                <div class="time-group">
                    <div class="form-group">
                        <label for="startTime">Start Time:</label>
                        <input type="time" id="startTime" required>
                    </div>
                    <div class="form-group">
                        <label for="endTime">End Time:</label>
                        <input type="time" id="endTime" required>
                    </div>
                </div>

                <div class="form-group">
                    <label for="leaveStatus">Leave Status:</label>
                    <select id="leaveStatus">
                        <option value="none">None</option>
                        <option value="vacation">Vacation</option>
                        <option value="sick">Sick Leave</option>
                        <option value="maternity">Maternity Leave</option>
                        <option value="paternity">Paternity Leave</option>
                        <option value="others">Others</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="overtimeStatus">Overtime Status:</label>
                    <select id="overtimeStatus">
                        <option value="none">None</option>
                        <option value="authorized">Authorized</option>
                    </select>
                </div>

                <!-- Attach ids to control buttons so event listeners can be bound in JavaScript.  
                     We keep the onclick attributes for backward compatibility, but the ids
                     allow script-based binding which is more reliable across browsers. -->
                <button id="addEntryBtn" type="button" class="btn" onclick="addEntry()">Add Entry</button>
                <button id="generateReportBtn" type="button" class="btn btn-secondary" onclick="generateReport()">Generate Report</button>
                <button id="exportExcelBtn" type="button" class="btn" onclick="exportToExcel()" style="background: linear-gradient(135deg, #059669 0%, #047857 100%);">📊 Export to Excel</button>
                <!-- New Save Data button to persist entries across sessions -->
                <button id="saveDataBtn" type="button" class="btn" style="background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);" onclick="saveData()">💾 Save Data</button>
                <button id="clearDataBtn" type="button" class="btn btn-danger" onclick="clearAllData()">Clear All Data</button>
            </div>

            <!-- Current Entries Display -->
            <div class="form-section">
                <h2>📊 Current Entries (<span id="entryCount">0</span>)</h2>
                <div class="entries-container">
                    <div id="entriesDisplay">
                        <p>No entries yet. Add your first time entry to get started!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Reports Section -->
        <div class="reports-section">
            <h2>📈 Workforce Analytics & FTE Reports</h2>
            <div id="reportsDisplay">
                <p>Generate a report to view detailed analytics and FTE calculations.</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Data storage
        let timeEntries = [];
        let nextId = 1;

        // Initialize with today's date
        document.getElementById('logDate').valueAsDate = new Date();

        function showAlert(message, type = 'success') {
            const alertContainer = document.getElementById('alertContainer');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            alertContainer.innerHTML = '';
            alertContainer.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 3000);
        }

        function validateForm() {
            const logDate = document.getElementById('logDate').value;
            const employeeName = document.getElementById('employeeName').value;
            const taskGroup = document.getElementById('taskGroup').value;
            const startTime = document.getElementById('startTime').value;
            const endTime = document.getElementById('endTime').value;

            if (!logDate) {
                showAlert('Please select a log date.', 'error');
                return false;
            }
            if (!employeeName) {
                showAlert('Please select an employee.', 'error');
                return false;
            }
            if (!taskGroup) {
                showAlert('Please select a task group.', 'error');
                return false;
            }
            // Consider placeholder values like "--:-- --" (displayed by some timepicker
            // libraries) as empty as well.  Without this check the form would
            // incorrectly pass validation even though the time inputs are not set.
            if (!startTime || startTime.trim() === '--:-- --') {
                showAlert('Please enter start time.', 'error');
                return false;
            }
            if (!endTime || endTime.trim() === '--:-- --') {
                showAlert('Please enter end time.', 'error');
                return false;
            }

            return true;
        }

        function addEntry() {
            if (!validateForm()) {
                return;
            }

            const entry = {
                id: nextId++,
                logDate: document.getElementById('logDate').value,
                employeeName: document.getElementById('employeeName').value,
                taskDescription: document.getElementById('taskDescription').value || 'No description provided',
                taskGroup: document.getElementById('taskGroup').value,
                startTime: document.getElementById('startTime').value,
                endTime: document.getElementById('endTime').value,
                leaveStatus: document.getElementById('leaveStatus').value,
                overtimeStatus: document.getElementById('overtimeStatus').value
            };

            // Calculate hours worked
            entry.hoursWorked = calculateHoursWorked(entry.startTime, entry.endTime, entry.leaveStatus);
            entry.dailyFTE = calculateDailyFTE(entry.hoursWorked);

            timeEntries.push(entry);
            displayEntries();
            clearForm();
            showAlert('Entry added successfully!');
        }

        /**
         * Parse a time string into hour and minute integers. Supports both
         * 24‑hour format (e.g., "13:45") and 12‑hour format with AM/PM
         * suffix (e.g., "05:40 AM").  If the input is malformed, returns
         * {hour: NaN, minute: NaN} so downstream code can handle gracefully.
         *
         * @param {string} timeString The time string from the input field
         * @returns {{hour: number, minute: number}}
         */
        function parseTimeString(timeString) {
            if (!timeString) {
                return { hour: NaN, minute: NaN };
            }
            // Trim whitespace
            const str = timeString.trim();
            // Check for AM/PM notation
            const ampmMatch = str.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
            if (ampmMatch) {
                let hour = parseInt(ampmMatch[1], 10);
                const minute = parseInt(ampmMatch[2], 10);
                const meridian = ampmMatch[3].toUpperCase();
                if (meridian === 'PM' && hour !== 12) {
                    hour += 12;
                }
                if (meridian === 'AM' && hour === 12) {
                    hour = 0;
                }
                return { hour, minute };
            }
            // Otherwise assume 24‑hour format HH:MM
            const parts = str.split(':');
            if (parts.length === 2) {
                const hour = parseInt(parts[0], 10);
                const minute = parseInt(parts[1], 10);
                return { hour, minute };
            }
            return { hour: NaN, minute: NaN };
        }

        function calculateHoursWorked(startTime, endTime, leaveStatus) {
            // Treat any type of leave as a full 8‑hour day.  This implements the
            // "Authorized Leave Day" rule where leave days count as a full
            // working day for FTE calculations.  If no leave is selected
            // (`leaveStatus` is "none"), fall through to normal calculation.
            if (leaveStatus && leaveStatus !== 'none') {
                return 8;
            }

            const start = parseTimeString(startTime);
            const end = parseTimeString(endTime);
            const startHour = start.hour;
            const startMinute = start.minute;
            const endHour = end.hour;
            const endMinute = end.minute;
            
            if (isNaN(startHour) || isNaN(startMinute) || isNaN(endHour) || isNaN(endMinute)) {
                return 0;
            }

            let startTotalMinutes = startHour * 60 + startMinute;
            let endTotalMinutes = endHour * 60 + endMinute;
            
            // Handle overnight shifts
            if (endTotalMinutes < startTotalMinutes) {
                endTotalMinutes += 24 * 60; // Add 24 hours
            }
            
            const diffMinutes = endTotalMinutes - startTotalMinutes;
            return Math.max(0, diffMinutes / 60); // Convert to hours
        }

        function calculateDailyFTE(hoursWorked) {
            return hoursWorked / 8; // Standard 8-hour workday
        }

        function clearForm() {
            document.getElementById('taskDescription').value = '';
            document.getElementById('startTime').value = '';
            document.getElementById('endTime').value = '';
            document.getElementById('leaveStatus').value = 'none';
            document.getElementById('overtimeStatus').value = 'none';
        }

        function displayEntries() {
            const display = document.getElementById('entriesDisplay');
            const countElement = document.getElementById('entryCount');
            
            countElement.textContent = timeEntries.length;
            
            if (timeEntries.length === 0) {
                display.innerHTML = '<p>No entries yet. Add your first time entry to get started!</p>';
                return;
            }

            let html = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Employee</th>
                            <th>Task Group</th>
                            <th>Start</th>
                            <th>End</th>
                            <th>Hours</th>
                            <th>FTE</th>
                            <th>Leave</th>
                            <th>OT</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            timeEntries.forEach(entry => {
                const shortEmployee = entry.employeeName.split(' ').slice(-2).join(' '); // Last 2 words
                const shortTaskGroup = entry.taskGroup.length > 25 ? entry.taskGroup.substring(0, 25) + '...' : entry.taskGroup;
                
                html += `
                    <tr>
                        <td>${entry.logDate}</td>
                        <td title="${entry.employeeName}">${shortEmployee}</td>
                        <td title="${entry.taskGroup}">${shortTaskGroup}</td>
                        <td>${entry.startTime}</td>
                        <td>${entry.endTime}</td>
                        <td>${entry.hoursWorked.toFixed(2)}</td>
                        <td>${entry.dailyFTE.toFixed(3)}</td>
                        <td>${entry.leaveStatus}</td>
                        <td>${entry.overtimeStatus}</td>
                        <td>
                            <button class="edit-btn" onclick="editEntry(${entry.id})">Edit</button>
                            <button class="delete-btn" onclick="deleteEntry(${entry.id})">Del</button>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            display.innerHTML = html;
        }

        function deleteEntry(id) {
            if (confirm('Are you sure you want to delete this entry?')) {
                timeEntries = timeEntries.filter(entry => entry.id !== id);
                displayEntries();
                showAlert('Entry deleted successfully!');
            }
        }

        /**
         * Load an existing entry into the form for editing. This allows users
         * to modify a previously saved entry. The entry is removed from the
         * current list and the form fields are populated with its data. After
         * making changes, the user should click "Add Entry" to re-save.
         * @param {number} id - The ID of the entry to edit.
         */
        function editEntry(id) {
            const index = timeEntries.findIndex(e => e.id === id);
            if (index === -1) {
                showAlert('Entry not found.', 'error');
                return;
            }
            const entry = timeEntries[index];
            // Populate form fields with entry data
            document.getElementById('logDate').value = entry.logDate;
            document.getElementById('employeeName').value = entry.employeeName;
            // If the task description was blank, leave the field empty for editing
            document.getElementById('taskDescription').value = (entry.taskDescription === 'No description provided') ? '' : entry.taskDescription;
            document.getElementById('taskGroup').value = entry.taskGroup;
            document.getElementById('startTime').value = entry.startTime;
            document.getElementById('endTime').value = entry.endTime;
            document.getElementById('leaveStatus').value = entry.leaveStatus;
            document.getElementById('overtimeStatus').value = entry.overtimeStatus;

            // Remove entry from list so it can be updated when re-added
            timeEntries.splice(index, 1);
            displayEntries();
            showAlert('Entry loaded for editing. Update the details and click Add Entry to save.');
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all data? This action cannot be undone.')) {
                timeEntries = [];
                nextId = 1;
                displayEntries();
                document.getElementById('reportsDisplay').innerHTML = '<p>Generate a report to view detailed analytics and FTE calculations.</p>';
                // Remove any saved data from localStorage as well
                localStorage.removeItem('timeEntries');
                showAlert('All data cleared successfully!');
            }
        }

        /**
         * Persist the current time entries to localStorage so that they are
         * available on future visits. The data is serialized to JSON and
         * stored under the key "timeEntries". A confirmation alert is shown
         * after saving. Users should click this after finalizing their inputs.
         */
        function saveData() {
            try {
                localStorage.setItem('timeEntries', JSON.stringify(timeEntries));
                showAlert('Data saved successfully!');
            } catch (e) {
                console.error('Failed to save data', e);
                showAlert('Failed to save data. See console for details.', 'error');
            }
        }

        /**
         * Load any previously saved time entries from localStorage. If entries
         * exist they replace the current in-memory list and the display is
         * refreshed. This should be invoked on page load to restore a user's
         * session. It also updates nextId so new entries continue from the
         * highest saved ID.
         */
        function loadSavedData() {
            const saved = localStorage.getItem('timeEntries');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed)) {
                        // Convert numeric values and ensure required fields exist
                        timeEntries = parsed.map(entry => {
                            return Object.assign({}, entry, {
                                hoursWorked: parseFloat(entry.hoursWorked),
                                dailyFTE: parseFloat(entry.dailyFTE)
                            });
                        });
                        // Update nextId to one greater than the current max
                        nextId = timeEntries.reduce((maxId, e) => Math.max(maxId, e.id || 0), 0) + 1;
                        displayEntries();
                        // If there were saved entries, automatically show the last generated report
                        const reportData = calculateReportData();
                        displayReport(reportData);
                    }
                } catch (e) {
                    console.error('Failed to parse saved data', e);
                }
            }
        }

        function generateReport() {
            if (timeEntries.length === 0) {
                showAlert('Please add some time entries before generating a report.', 'error');
                return;
            }

            const reportData = calculateReportData();
            displayReport(reportData);
            showAlert('Report generated successfully!');
        }

        function calculateReportData() {
            const employeeData = {};
            
            // Group data by employee
            timeEntries.forEach(entry => {
                if (!employeeData[entry.employeeName]) {
                    employeeData[entry.employeeName] = {
                        name: entry.employeeName,
                        entries: [],
                        totalHours: 0,
                        workingDays: new Set(),
                        taskGroups: new Set(),
                        leaveHours: 0,
                        overtimeHours: 0
                    };
                }
                
                const employee = employeeData[entry.employeeName];
                employee.entries.push(entry);
                employee.totalHours += entry.hoursWorked;
                employee.taskGroups.add(entry.taskGroup);
                
                if (entry.hoursWorked > 0) {
                    employee.workingDays.add(entry.logDate);
                }
                
                if (entry.leaveStatus !== 'none') {
                    employee.leaveHours += 8; // Assume full day for leave
                }
                
                if (entry.overtimeStatus === 'authorized' && entry.hoursWorked > 8) {
                    employee.overtimeHours += (entry.hoursWorked - 8);
                }
            });

            // Calculate weekly and monthly data
            Object.keys(employeeData).forEach(employeeName => {
                const employee = employeeData[employeeName];
                employee.workingDaysCount = employee.workingDays.size;
                employee.taskGroupsCount = employee.taskGroups.size;
                
                // Group entries by week and month
                const weeklyData = {};
                const monthlyData = {};
                
                employee.entries.forEach(entry => {
                    const date = new Date(entry.logDate);
                    const weekKey = getWeekKey(date);
                    const monthKey = getMonthKey(date);
                    
                    if (!weeklyData[weekKey]) weeklyData[weekKey] = 0;
                    if (!monthlyData[monthKey]) monthlyData[monthKey] = 0;
                    
                    weeklyData[weekKey] += entry.hoursWorked;
                    monthlyData[monthKey] += entry.hoursWorked;
                });
                
                // Calculate FTE metrics
                employee.averageDailyHours = employee.workingDaysCount > 0 ? employee.totalHours / employee.workingDaysCount : 0;
                employee.averageDailyFTE = employee.averageDailyHours / 8;
                
                // Weekly FTE calculations
                employee.weeklyHours = Object.values(weeklyData);
                employee.weeklyFTEs = employee.weeklyHours.map(hours => hours / 40);
                employee.averageWeeklyFTE = employee.weeklyFTEs.length > 0 ? 
                    employee.weeklyFTEs.reduce((sum, fte) => sum + fte, 0) / employee.weeklyFTEs.length : 0;
                
                // Monthly FTE calculations
                employee.monthlyHours = Object.values(monthlyData);
                employee.monthlyFTEs = employee.monthlyHours.map(hours => hours / 160); // 20 working days * 8 hours
                employee.averageMonthlyFTE = employee.monthlyFTEs.length > 0 ? 
                    employee.monthlyFTEs.reduce((sum, fte) => sum + fte, 0) / employee.monthlyFTEs.length : 0;
            });

            return employeeData;
        }

        function getWeekKey(date) {
            const year = date.getFullYear();
            const week = getWeekNumber(date);
            return `${year}-W${week.toString().padStart(2, '0')}`;
        }

        function getMonthKey(date) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            return `${year}-${month.toString().padStart(2, '0')}`;
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function displayReport(reportData) {
            const display = document.getElementById('reportsDisplay');
            
            // Calculate summary statistics
            const employees = Object.values(reportData);
            const totalEmployees = employees.length;
            const totalHours = employees.reduce((sum, emp) => sum + emp.totalHours, 0);
            const totalWorkingDays = employees.reduce((sum, emp) => sum + emp.workingDaysCount, 0);
            const averageHoursPerEmployee = totalEmployees > 0 ? totalHours / totalEmployees : 0;
            const overallAverageFTE = employees.length > 0 ? 
                employees.reduce((sum, emp) => sum + emp.averageDailyFTE, 0) / employees.length : 0;

            // Prepare weekly and monthly summary statistics for each employee.  These
            // summaries are later rendered into tables to provide more insight into
            // hours worked and FTE across the week and month.  Without these
            // calculations the "Weekly" and "Monthly" sections were empty.
            const weeklySummary = employees.map(emp => {
                const totalWeeklyHours = emp.weeklyHours.reduce((sum, h) => sum + h, 0);
                const weeks = emp.weeklyHours.length;
                const avgWeeklyHours = weeks > 0 ? totalWeeklyHours / weeks : 0;
                return {
                    name: emp.name,
                    totalWeeklyHours,
                    weeks,
                    avgWeeklyHours,
                    averageWeeklyFTE: emp.averageWeeklyFTE
                };
            });
            const monthlySummary = employees.map(emp => {
                const totalMonthlyHours = emp.monthlyHours.reduce((sum, h) => sum + h, 0);
                const months = emp.monthlyHours.length;
                const avgMonthlyHours = months > 0 ? totalMonthlyHours / months : 0;
                return {
                    name: emp.name,
                    totalMonthlyHours,
                    months,
                    avgMonthlyHours,
                    averageMonthlyFTE: emp.averageMonthlyFTE
                };
            });

            // Calculate task group distribution early so it can be placed
            // before the Detailed Employee FTE report.  Build a string of
            // table rows that will be injected into the HTML template.  If
            // there are no time entries, this will remain empty.
            const taskGroups = {};
            timeEntries.forEach(entry => {
                if (!taskGroups[entry.taskGroup]) {
                    taskGroups[entry.taskGroup] = { hours: 0, count: 0 };
                }
                taskGroups[entry.taskGroup].hours += entry.hoursWorked;
                taskGroups[entry.taskGroup].count += 1;
            });
            const taskGroupRows = Object.entries(taskGroups)
                .sort(([, a], [, b]) => b.hours - a.hours)
                .map(([taskGroup, data]) => {
                    const percentage = totalHours > 0 ? (data.hours / totalHours * 100).toFixed(1) : '0.0';
                    const avgHours = data.count > 0 ? (data.hours / data.count).toFixed(2) : '0.00';
                    return `
                        <tr>
                            <td>${taskGroup}</td>
                            <td>${data.hours.toFixed(2)}</td>
                            <td>${percentage}%</td>
                            <td>${data.count}</td>
                            <td>${avgHours}</td>
                        </tr>
                    `;
                }).join('');
            
            let html = `
                <div class="report-cards">
                    <div class="report-card">
                        <h3>Total Employees</h3>
                        <div class="value">${totalEmployees}</div>
                        <div class="label">Active employees tracked</div>
                    </div>
                    <div class="report-card">
                        <h3>Total Hours</h3>
                        <div class="value">${totalHours.toFixed(1)}</div>
                        <div class="label">Combined work hours</div>
                    </div>
                    <div class="report-card">
                        <h3>Total Working Days</h3>
                        <div class="value">${totalWorkingDays}</div>
                        <div class="label">Days with logged hours</div>
                    </div>
                    <div class="report-card">
                        <h3>Avg Hours/Employee</h3>
                        <div class="value">${averageHoursPerEmployee.toFixed(1)}</div>
                        <div class="label">Per employee average</div>
                    </div>
                    <div class="report-card">
                        <h3>Overall Avg FTE</h3>
                        <div class="value">${overallAverageFTE.toFixed(3)}</div>
                        <div class="label">Daily FTE average</div>
                    </div>
                    <div class="report-card">
                        <h3>Total Entries</h3>
                        <div class="value">${timeEntries.length}</div>
                        <div class="label">Time log entries</div>
                    </div>
                </div>

                <h3>📊 Task Group Distribution</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Task Group</th>
                            <th>Total Hours</th>
                            <th>Percentage</th>
                            <th>Entries</th>
                            <th>Avg Hours/Entry</th>
                        </tr>
                    </thead>
                    <tbody>
                    ${taskGroupRows}
                    </tbody>
                </table>

                <h3>📋 Detailed Employee FTE Report</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Employee Name</th>
                            <th>Total Hours</th>
                            <th>Working Days</th>
                            <th>Avg Daily Hours</th>
                            <th>Daily FTE</th>
                            <th>Weekly FTE</th>
                            <th>Monthly FTE</th>
                            <th>Task Groups</th>
                            <th>Overtime Hours</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            employees.forEach(employee => {
                html += `
                    <tr>
                        <td>${employee.name}</td>
                        <td>${employee.totalHours.toFixed(2)}</td>
                        <td>${employee.workingDaysCount}</td>
                        <td>${employee.averageDailyHours.toFixed(2)}</td>
                        <td>${employee.averageDailyFTE.toFixed(3)}</td>
                        <td>${employee.averageWeeklyFTE.toFixed(3)}</td>
                        <td>${employee.averageMonthlyFTE.toFixed(3)}</td>
                        <td>${employee.taskGroupsCount}</td>
                        <td>${employee.overtimeHours.toFixed(2)}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            // Build the weekly summary section.  It shows per‑employee totals,
            // counts and averages so that users can gauge effort each week.
            html += `
                <h3>📅 Weekly Summary</h3>
                <p><strong>Note:</strong> Weekly FTE is calculated based on a 40‑hour standard work week.</p>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Employee</th>
                            <th>Total Weekly Hours</th>
                            <th>Weeks</th>
                            <th>Avg Weekly Hours</th>
                            <th>Avg Weekly FTE</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            weeklySummary.forEach(row => {
                html += `
                        <tr>
                            <td>${row.name}</td>
                            <td>${row.totalWeeklyHours.toFixed(2)}</td>
                            <td>${row.weeks}</td>
                            <td>${row.avgWeeklyHours.toFixed(2)}</td>
                            <td>${row.averageWeeklyFTE.toFixed(3)}</td>
                        </tr>
                `;
            });
            html += `
                    </tbody>
                </table>
            `;

            // Build the monthly summary section.  It mirrors the weekly section
            // but aggregates by month and uses a 160‑hour standard month.
            html += `
                <h3>📅 Monthly Summary</h3>
                <p><strong>Note:</strong> Monthly FTE is calculated based on a 160‑hour standard work month (20 working days × 8 hours).</p>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Employee</th>
                            <th>Total Monthly Hours</th>
                            <th>Months</th>
                            <th>Avg Monthly Hours</th>
                            <th>Avg Monthly FTE</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            monthlySummary.forEach(row => {
                html += `
                        <tr>
                            <td>${row.name}</td>
                            <td>${row.totalMonthlyHours.toFixed(2)}</td>
                            <td>${row.months}</td>
                            <td>${row.avgMonthlyHours.toFixed(2)}</td>
                            <td>${row.averageMonthlyFTE.toFixed(3)}</td>
                        </tr>
                `;
            });
            html += `
                    </tbody>
                </table>
            `;

            // Calculation details remain unchanged but are appended after the summaries
            html += `
                <h3>🔍 Calculation Details</h3>
                <ul style="margin: 15px 0; padding-left: 20px;">
                    <li><strong>Daily FTE:</strong> Daily Hours ÷ 8 hours</li>
                    <li><strong>Weekly FTE:</strong> Weekly Hours ÷ 40 hours</li>
                    <li><strong>Monthly FTE:</strong> Monthly Hours ÷ 160 hours</li>
                    <li><strong>Authorized Leave Day:</strong> Count as 8 hours worked</li>
                    <li><strong>Overtime:</strong> Hours beyond 8 hours per day (when authorized)</li>
                </ul>

                <h3>📊 Dashboard Overview</h3>
                <!-- Dashboard menu allows users to choose what data they wish to visualize. -->
                <div class="dashboard-menu" style="margin-bottom:20px;">
                    <!-- Timeframe selection (daily/weekly/monthly) -->
                    <label for="timeScaleSelect"><strong>Timeframe:</strong></label>
                    <select id="timeScaleSelect" onchange="updateMetricOptions(); updatePeriodOptions();" style="margin-right:10px;">
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                        <option value="monthly">Monthly</option>
                    </select>
                    <!-- Metric selection (average hours or FTE).  Provide default
                         options to ensure the dropdown is populated even if
                         updateMetricOptions() is not called for some reason. -->
                    <label for="metricSelect"><strong>Metric:</strong></label>
                    <select id="metricSelect" onchange="updatePeriodOptions();" style="margin-right:10px;">
                        <option value="average-hours">Average Hours</option>
                        <option value="fte">FTE</option>
                    </select>
                    <!-- Generate button for the dashboard.  The nested menu only
                         includes timeframe and metric selections; the period
                         selector was removed because it caused issues with the
                         chart not rendering.  When the user clicks this button
                         the chart will be generated for the chosen timeframe
                         and metric across all available data. -->
                    <button class="btn" id="generateChartBtn" onclick="generateDashboardChart();" style="padding:6px 12px;">Generate Chart</button>
                </div>
                <!-- The dashboard-container will be populated with charts only when the user triggers generation. -->
                <div class="dashboard-container"></div>
            `;
            
            display.innerHTML = html;

            // Store employees globally for dashboard use and prepare
            // period lists (daily, weekly, monthly).  Populate the
            // dashboard menu so the user can choose which chart to
            // generate.  We no longer automatically generate charts
            // here; instead, the user must select a timeframe and
            // metric via the nested dropdown menu and click
            // "Generate Chart".
            dashboardEmployees = employees;
            prepareDashboardData(employees);
            populateDashboardMenu();
        }

        // Initialize display
        displayEntries();
        // Load any saved entries from previous sessions. This will overwrite
        // the in-memory list with persisted data and refresh the display.
        loadSavedData();

        // Attach event listeners to action buttons. Since this script is loaded
        // at the end of the page, the DOM is already constructed, so we can
        // safely bind handlers immediately without waiting for DOMContentLoaded.
        // We still check for the existence of each button before adding
        // listeners to avoid runtime errors.
        (function() {
            const addBtn = document.getElementById('addEntryBtn');
            if (addBtn) addBtn.addEventListener('click', addEntry);
            const reportBtn = document.getElementById('generateReportBtn');
            if (reportBtn) reportBtn.addEventListener('click', generateReport);
            const exportBtn = document.getElementById('exportExcelBtn');
            if (exportBtn) exportBtn.addEventListener('click', exportToExcel);
            const saveBtn = document.getElementById('saveDataBtn');
            if (saveBtn) saveBtn.addEventListener('click', saveData);
            const clearBtn = document.getElementById('clearDataBtn');
            if (clearBtn) clearBtn.addEventListener('click', clearAllData);
        })();

        function exportToExcel() {
            if (timeEntries.length === 0) {
                showAlert('No data to export. Please add some entries first.', 'error');
                return;
            }

            try {
                // Create a new workbook
                const workbook = XLSX.utils.book_new();

                // Sheet 1: Raw Time Entries
                const rawData = timeEntries.map(entry => ({
                    'Log Date': entry.logDate,
                    'Employee Name': entry.employeeName,
                    'Task Description': entry.taskDescription,
                    'Task Group': entry.taskGroup,
                    'Start Time': entry.startTime,
                    'End Time': entry.endTime,
                    'Hours Worked': parseFloat(entry.hoursWorked.toFixed(2)),
                    'Daily FTE': parseFloat(entry.dailyFTE.toFixed(3)),
                    'Leave Status': entry.leaveStatus,
                    'Overtime Status': entry.overtimeStatus
                }));

                const rawDataSheet = XLSX.utils.json_to_sheet(rawData);
                
                // Auto-width columns for raw data
                const rawDataCols = [
                    { wch: 12 }, // Log Date
                    { wch: 25 }, // Employee Name
                    { wch: 40 }, // Task Description
                    { wch: 35 }, // Task Group
                    { wch: 10 }, // Start Time
                    { wch: 10 }, // End Time
                    { wch: 12 }, // Hours Worked
                    { wch: 10 }, // Daily FTE
                    { wch: 12 }, // Leave Status
                    { wch: 15 }  // Overtime Status
                ];
                rawDataSheet['!cols'] = rawDataCols;

                XLSX.utils.book_append_sheet(workbook, rawDataSheet, 'Time Entries');

                // Sheet 2: Employee Summary (if we have report data)
                if (timeEntries.length > 0) {
                    const reportData = calculateReportData();
                    const employees = Object.values(reportData);
                    
                    const summaryData = employees.map(employee => ({
                        'Employee Name': employee.name,
                        'Total Hours': parseFloat(employee.totalHours.toFixed(2)),
                        'Working Days': employee.workingDaysCount,
                        'Average Daily Hours': parseFloat(employee.averageDailyHours.toFixed(2)),
                        'Daily FTE': parseFloat(employee.averageDailyFTE.toFixed(3)),
                        'Weekly FTE': parseFloat(employee.averageWeeklyFTE.toFixed(3)),
                        'Monthly FTE': parseFloat(employee.averageMonthlyFTE.toFixed(3)),
                        'Task Groups Count': employee.taskGroupsCount,
                        'Overtime Hours': parseFloat(employee.overtimeHours.toFixed(2)),
                        'Leave Hours': parseFloat(employee.leaveHours.toFixed(2))
                    }));

                    const summarySheet = XLSX.utils.json_to_sheet(summaryData);
                    
                    // Auto-width columns for summary
                    const summaryCols = [
                        { wch: 25 }, // Employee Name
                        { wch: 12 }, // Total Hours
                        { wch: 12 }, // Working Days
                        { wch: 15 }, // Average Daily Hours
                        { wch: 10 }, // Daily FTE
                        { wch: 12 }, // Weekly FTE
                        { wch: 12 }, // Monthly FTE
                        { wch: 15 }, // Task Groups Count
                        { wch: 12 }, // Overtime Hours
                        { wch: 12 }  // Leave Hours
                    ];
                    summarySheet['!cols'] = summaryCols;

                    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Employee Summary');

                    // Sheet 3: Task Group Analysis
                    const taskGroups = {};
                    timeEntries.forEach(entry => {
                        if (!taskGroups[entry.taskGroup]) {
                            taskGroups[entry.taskGroup] = { hours: 0, count: 0 };
                        }
                        taskGroups[entry.taskGroup].hours += entry.hoursWorked;
                        taskGroups[entry.taskGroup].count += 1;
                    });

                    const totalHours = employees.reduce((sum, emp) => sum + emp.totalHours, 0);
                    const taskGroupData = Object.entries(taskGroups)
                        .sort(([,a], [,b]) => b.hours - a.hours)
                        .map(([taskGroup, data]) => ({
                            'Task Group': taskGroup,
                            'Total Hours': parseFloat(data.hours.toFixed(2)),
                            'Percentage': parseFloat((data.hours / totalHours * 100).toFixed(1)),
                            'Entry Count': data.count,
                            'Average Hours per Entry': parseFloat((data.hours / data.count).toFixed(2))
                        }));

                    const taskGroupSheet = XLSX.utils.json_to_sheet(taskGroupData);
                    
                    // Auto-width columns for task groups
                    const taskGroupCols = [
                        { wch: 45 }, // Task Group
                        { wch: 12 }, // Total Hours
                        { wch: 12 }, // Percentage
                        { wch: 12 }, // Entry Count
                        { wch: 20 }  // Average Hours per Entry
                    ];
                    taskGroupSheet['!cols'] = taskGroupCols;

                    XLSX.utils.book_append_sheet(workbook, taskGroupSheet, 'Task Group Analysis');

                    // Sheet 4: Weekly Breakdown
                    const weeklyBreakdown = [];
                    employees.forEach(employee => {
                        employee.entries.forEach(entry => {
                            const date = new Date(entry.logDate);
                            const weekKey = getWeekKey(date);
                            weeklyBreakdown.push({
                                'Week': weekKey,
                                'Employee Name': employee.name,
                                'Date': entry.logDate,
                                'Hours': parseFloat(entry.hoursWorked.toFixed(2)),
                                'Daily FTE': parseFloat(entry.dailyFTE.toFixed(3)),
                                'Task Group': entry.taskGroup
                            });
                        });
                    });

                    // Sort by week and employee
                    weeklyBreakdown.sort((a, b) => {
                        if (a.Week !== b.Week) return a.Week.localeCompare(b.Week);
                        return a['Employee Name'].localeCompare(b['Employee Name']);
                    });

                    const weeklySheet = XLSX.utils.json_to_sheet(weeklyBreakdown);
                    
                    // Auto-width columns for weekly breakdown
                    const weeklyCols = [
                        { wch: 12 }, // Week
                        { wch: 25 }, // Employee Name
                        { wch: 12 }, // Date
                        { wch: 10 }, // Hours
                        { wch: 10 }, // Daily FTE
                        { wch: 35 }  // Task Group
                    ];
                    weeklySheet['!cols'] = weeklyCols;

                    XLSX.utils.book_append_sheet(workbook, weeklySheet, 'Weekly Breakdown');

                    // Sheet 5: Monthly Breakdown
                    const monthlyBreakdown = [];
                    employees.forEach(employee => {
                        const monthlyData = {};
                        employee.entries.forEach(entry => {
                            const date = new Date(entry.logDate);
                            const monthKey = getMonthKey(date);
                            if (!monthlyData[monthKey]) {
                                monthlyData[monthKey] = {
                                    hours: 0,
                                    days: new Set(),
                                    taskGroups: new Set()
                                };
                            }
                            monthlyData[monthKey].hours += entry.hoursWorked;
                            monthlyData[monthKey].days.add(entry.logDate);
                            monthlyData[monthKey].taskGroups.add(entry.taskGroup);
                        });

                        Object.entries(monthlyData).forEach(([month, data]) => {
                            monthlyBreakdown.push({
                                'Month': month,
                                'Employee Name': employee.name,
                                'Total Hours': parseFloat(data.hours.toFixed(2)),
                                'Working Days': data.days.size,
                                'Monthly FTE': parseFloat((data.hours / 160).toFixed(3)),
                                'Task Groups': data.taskGroups.size,
                                'Average Daily Hours': parseFloat((data.hours / data.days.size).toFixed(2))
                            });
                        });
                    });

                    // Sort by month and employee
                    monthlyBreakdown.sort((a, b) => {
                        if (a.Month !== b.Month) return a.Month.localeCompare(b.Month);
                        return a['Employee Name'].localeCompare(b['Employee Name']);
                    });

                    const monthlySheet = XLSX.utils.json_to_sheet(monthlyBreakdown);
                    
                    // Auto-width columns for monthly breakdown
                    const monthlyCols = [
                        { wch: 10 }, // Month
                        { wch: 25 }, // Employee Name
                        { wch: 12 }, // Total Hours
                        { wch: 12 }, // Working Days
                        { wch: 12 }, // Monthly FTE
                        { wch: 12 }, // Task Groups
                        { wch: 18 }  // Average Daily Hours
                    ];
                    monthlySheet['!cols'] = monthlyCols;

                    XLSX.utils.book_append_sheet(workbook, monthlySheet, 'Monthly Breakdown');
                }

                // Generate filename with current date
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD format
                const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS format
                const filename = `Workforce_Management_Report_${dateStr}_${timeStr}.xlsx`;

                // Write and download the file
                XLSX.writeFile(workbook, filename);
                
                showAlert(`Excel file exported successfully as: ${filename}`);
                
            } catch (error) {
                console.error('Export error:', error);
                showAlert('Error exporting to Excel. Please try again.', 'error');
            }
        }

        /*
         * Set up interactive dashboard charts using Chart.js.  This helper
         * function is called after the report is rendered and takes the
         * array of aggregated employee objects.  It builds bar charts for
         * total hours and average daily FTE per employee.  Previous chart
         * instances are destroyed to avoid memory leaks on repeated report
         * generation.
         */
        /**
         * Build simple horizontal bar charts in place of the previous
         * Chart.js implementation.  The charts visualize total hours and
         * average daily FTE per employee using plain HTML and CSS for
         * maximum compatibility and zero external dependencies.  Each
         * chart is rendered inside the .dashboard-container with its own
         * heading and rows.
         *
         * @param {Array} employees - aggregated employee summary data
         */
        function setupDashboard(employees) {
            const container = document.querySelector('.dashboard-container');
            // Clear any existing content
            container.innerHTML = '';

            if (!Array.isArray(employees) || employees.length === 0) {
                return;
            }

        // ---------------------------------------------------------------------------

            // Compute maximums for scaling bars
            const maxTotalHours = Math.max(...employees.map(emp => emp.totalHours));
            const maxAvgDailyFTE = Math.max(...employees.map(emp => emp.averageDailyFTE));

            // Helper to create a bar chart section
            function createBarChart(title, values, maxValue, unit) {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'custom-bar-chart';
                // Title
                const header = document.createElement('h4');
                header.textContent = title;
                chartDiv.appendChild(header);
                // Rows
                employees.forEach((emp, index) => {
                    const value = values[index];
                    // Avoid division by zero
                    const percentage = maxValue > 0 ? (value / maxValue) * 100 : 0;
                    const row = document.createElement('div');
                    row.className = 'bar-row';
                    // Label
                    const label = document.createElement('div');
                    label.className = 'bar-label';
                    label.textContent = `${emp.name}`;
                    row.appendChild(label);
                    // Bar
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.width = percentage + '%';
                    // Format value to 2 decimal places for hours and 3 for FTE
                    const formattedValue = unit === 'hours' ? value.toFixed(2) : value.toFixed(3);
                    bar.setAttribute('data-value', `${formattedValue}`);
                    row.appendChild(bar);
                    chartDiv.appendChild(row);
                });
                return chartDiv;
            }

            // Prepare values for charts
            const totalHoursValues = employees.map(emp => emp.totalHours);
            const avgDailyHoursValues = employees.map(emp => emp.averageDailyHours);
            // Compute average weekly and monthly hours for each employee
            const avgWeeklyHoursValues = employees.map(emp => {
                const weeks = Array.isArray(emp.weeklyHours) ? emp.weeklyHours.length : 0;
                const total = Array.isArray(emp.weeklyHours) ? emp.weeklyHours.reduce((sum, h) => sum + h, 0) : 0;
                return weeks > 0 ? total / weeks : 0;
            });
            const avgMonthlyHoursValues = employees.map(emp => {
                const months = Array.isArray(emp.monthlyHours) ? emp.monthlyHours.length : 0;
                const total = Array.isArray(emp.monthlyHours) ? emp.monthlyHours.reduce((sum, h) => sum + h, 0) : 0;
                return months > 0 ? total / months : 0;
            });
            // FTE values
            const avgDailyFTEValues = employees.map(emp => emp.averageDailyFTE);
            const avgWeeklyFTEValues = employees.map(emp => emp.averageWeeklyFTE);
            const avgMonthlyFTEValues = employees.map(emp => emp.averageMonthlyFTE);

            // Determine maxima for scaling
            const maxAvgDailyHours = Math.max(...avgDailyHoursValues);
            const maxAvgWeeklyHours = Math.max(...avgWeeklyHoursValues);
            const maxAvgMonthlyHours = Math.max(...avgMonthlyHoursValues);
            const maxDailyFTE = Math.max(...avgDailyFTEValues);
            const maxWeeklyFTE = Math.max(...avgWeeklyFTEValues);
            const maxMonthlyFTE = Math.max(...avgMonthlyFTEValues);

            // Build the Total Hours by Employee chart
            const hoursChart = createBarChart('Total Hours by Employee', totalHoursValues, maxTotalHours, 'hours');
            container.appendChild(hoursChart);

            // Build average hours charts
            const dailyHoursChart = createBarChart('Average Daily Hours by Employee', avgDailyHoursValues, maxAvgDailyHours, 'hours');
            container.appendChild(dailyHoursChart);
            const weeklyHoursChart = createBarChart('Average Weekly Hours by Employee', avgWeeklyHoursValues, maxAvgWeeklyHours, 'hours');
            container.appendChild(weeklyHoursChart);
            const monthlyHoursChart = createBarChart('Average Monthly Hours by Employee', avgMonthlyHoursValues, maxAvgMonthlyHours, 'hours');
            container.appendChild(monthlyHoursChart);

            // Build average FTE charts
            const dailyFTEChart = createBarChart('Average Daily FTE by Employee', avgDailyFTEValues, maxDailyFTE, 'fte');
            container.appendChild(dailyFTEChart);
            const weeklyFTEChart = createBarChart('Average Weekly FTE by Employee', avgWeeklyFTEValues, maxWeeklyFTE, 'fte');
            container.appendChild(weeklyFTEChart);
            const monthlyFTEChart = createBarChart('Average Monthly FTE by Employee', avgMonthlyFTEValues, maxMonthlyFTE, 'fte');
            container.appendChild(monthlyFTEChart);
        }

        // End of setupDashboard function

        // =======================================================================
        // Dashboard nested menu global variables and helper functions
        //
        // These variables and functions are defined in the global scope so
        // they can be accessed by the HTML event handlers (e.g., the
        // onchange and onclick attributes on the dashboard menu).  If
        // defined inside setupDashboard they would not be visible
        // outside that function, causing the Metric and Generate Chart
        // controls to break.  Do not remove or rename these without
        // updating the associated event handlers in the HTML.

        // Global array of aggregated employee objects currently loaded in
        // the report.  Populated from displayReport().
        let dashboardEmployees = [];
        // Global object containing arrays of unique period keys for each
        // timeframe.  Populated in prepareDashboardData().
        let dashboardPeriods = { daily: [], weekly: [], monthly: [] };

        /**
         * Prepare dashboard data by calculating daily, weekly and monthly
         * dictionaries for each employee and collecting unique period keys
         * across all employees.  These period keys populate the period
         * dropdown so the user can filter by a specific day, week or
         * month.  The function also precomputes average weekly and
         * monthly hours for use when the user selects the "All" option.
         *
         * @param {Array<Object>} employees - aggregated employee data
         */
        function prepareDashboardData(employees) {
            const dailySet = new Set();
            const weeklySet = new Set();
            const monthlySet = new Set();
            employees.forEach(emp => {
                const dailyDict = {};
                const weeklyDict = {};
                const monthlyDict = {};
                // Find all time entries for this employee.  Use the correct
                // property names from the time entry structure (employeeName
                // and logDate).  Previously this used e.employee and e.date,
                // which are undefined on our entry objects and resulted in
                // empty dictionaries.  Fixing these references ensures that
                // weekly and monthly averages compute correctly.
                timeEntries.filter(e => e.employeeName === emp.name).forEach(entry => {
                    // Daily key (YYYY-MM-DD)
                    const dayKey = entry.logDate;
                    dailyDict[dayKey] = (dailyDict[dayKey] || 0) + entry.hoursWorked;
                    dailySet.add(dayKey);
                    // Weekly key (YYYY-Wxx)
                    const entryDate = new Date(entry.logDate);
                    const weekNum = getWeekNumber(entryDate);
                    const year = entryDate.getFullYear();
                    const weekKey = `${year}-W${weekNum.toString().padStart(2, '0')}`;
                    weeklyDict[weekKey] = (weeklyDict[weekKey] || 0) + entry.hoursWorked;
                    weeklySet.add(weekKey);
                    // Monthly key (YYYY-MM)
                    const monthKey = getMonthKey(entryDate);
                    monthlyDict[monthKey] = (monthlyDict[monthKey] || 0) + entry.hoursWorked;
                    monthlySet.add(monthKey);
                });
                emp.dailyHoursDict = dailyDict;
                emp.weeklyHoursDict = weeklyDict;
                emp.monthlyHoursDict = monthlyDict;
                const weeklyValues = Object.values(weeklyDict);
                emp.averageWeeklyHours = weeklyValues.length > 0 ? weeklyValues.reduce((s, h) => s + h, 0) / weeklyValues.length : 0;
                const monthlyValues = Object.values(monthlyDict);
                emp.averageMonthlyHours = monthlyValues.length > 0 ? monthlyValues.reduce((s, h) => s + h, 0) / monthlyValues.length : 0;
            });
            dashboardPeriods.daily = Array.from(dailySet).sort();
            dashboardPeriods.weekly = Array.from(weeklySet).sort();
            dashboardPeriods.monthly = Array.from(monthlySet).sort();
        }

        /**
         * Populate the dashboard menu selects.  Delegates to
         * updateMetricOptions() and updatePeriodOptions() so the selects
         * reflect the current timeframe selection.  Call this after
         * prepareDashboardData() whenever the employee data changes.
         */
        function populateDashboardMenu() {
            updateMetricOptions();
            updatePeriodOptions();
        }

        /**
         * Update the metric select based on the selected timeframe.  All
         * timeframes support the same two metrics: average hours and FTE.
         */
        function updateMetricOptions() {
            const metricSelect = document.getElementById('metricSelect');
            metricSelect.innerHTML = '';
            ['Average Hours', 'FTE'].forEach(label => {
                const option = document.createElement('option');
                option.value = label.toLowerCase().replace(/ /g, '-');
                option.textContent = label;
                metricSelect.appendChild(option);
            });
        }

        /**
         * Update the period options based on the selected timeframe.  Shows
         * or hides the period dropdown depending on whether any periods
         * exist.  Always includes an "All" option so the user can view
         * aggregated averages across all days, weeks or months.
         */
        function updatePeriodOptions() {
            const timeScale = document.getElementById('timeScaleSelect').value;
            // The period selector has been removed from the dashboard menu. If no
            // period select exists, there's nothing to update. Guard against
            // null references here so the function can be safely called.
            const periodSelect = document.getElementById('periodSelect');
            const periodLabel = document.getElementById('periodLabel');
            if (!periodSelect || !periodLabel || !dashboardPeriods) {
                return;
            }
            let list = [];
            if (timeScale === 'daily') {
                list = dashboardPeriods.daily;
            } else if (timeScale === 'weekly') {
                list = dashboardPeriods.weekly;
            } else if (timeScale === 'monthly') {
                list = dashboardPeriods.monthly;
            }
            periodSelect.innerHTML = '';
            const allOpt = document.createElement('option');
            allOpt.value = 'all';
            allOpt.textContent = 'All';
            periodSelect.appendChild(allOpt);
            list.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                periodSelect.appendChild(opt);
            });
            if (list.length > 0) {
                periodLabel.style.display = '';
                periodSelect.style.display = '';
            } else {
                periodLabel.style.display = 'none';
                periodSelect.style.display = 'none';
            }
        }

        /**
         * Generate a bar chart based on the user's selections in the
         * dashboard menu.  Computes values for each employee according to
         * the selected timeframe, metric and period (all or specific) and
         * renders the chart using createBarChart().
         */
        function generateDashboardChart() {
            const timeScale = document.getElementById('timeScaleSelect').value;
            const metric = document.getElementById('metricSelect').value;
            // A separate period selector has been removed from the dashboard.
            // Always aggregate over all periods when generating charts.
            const period = 'all';
            const container = document.querySelector('.dashboard-container');
            container.innerHTML = '';
            if (!dashboardEmployees || dashboardEmployees.length === 0) return;
            const values = [];
            let maxValue = 0;
            let unit = 'hours';
            dashboardEmployees.forEach(emp => {
                let value = 0;
                if (timeScale === 'daily') {
                    if (period === 'all') {
                        if (metric === 'average-hours') {
                            value = emp.averageDailyHours || 0;
                            unit = 'hours';
                        } else {
                            value = emp.averageDailyFTE || 0;
                            unit = 'fte';
                        }
                    } else {
                        const hours = emp.dailyHoursDict && emp.dailyHoursDict[period] ? emp.dailyHoursDict[period] : 0;
                        if (metric === 'average-hours') {
                            value = hours;
                            unit = 'hours';
                        } else {
                            value = hours / 8;
                            unit = 'fte';
                        }
                    }
                } else if (timeScale === 'weekly') {
                    if (period === 'all') {
                        if (metric === 'average-hours') {
                            value = emp.averageWeeklyHours || 0;
                            unit = 'hours';
                        } else {
                            value = emp.averageWeeklyFTE || 0;
                            unit = 'fte';
                        }
                    } else {
                        const hours = emp.weeklyHoursDict && emp.weeklyHoursDict[period] ? emp.weeklyHoursDict[period] : 0;
                        if (metric === 'average-hours') {
                            value = hours;
                            unit = 'hours';
                        } else {
                            value = hours / 40;
                            unit = 'fte';
                        }
                    }
                } else if (timeScale === 'monthly') {
                    if (period === 'all') {
                        if (metric === 'average-hours') {
                            value = emp.averageMonthlyHours || 0;
                            unit = 'hours';
                        } else {
                            value = emp.averageMonthlyFTE || 0;
                            unit = 'fte';
                        }
                    } else {
                        const hours = emp.monthlyHoursDict && emp.monthlyHoursDict[period] ? emp.monthlyHoursDict[period] : 0;
                        if (metric === 'average-hours') {
                            value = hours;
                            unit = 'hours';
                        } else {
                            value = hours / 160;
                            unit = 'fte';
                        }
                    }
                }
                values.push(value);
                if (value > maxValue) maxValue = value;
            });
            const metricName = metric === 'average-hours' ? 'Hours' : 'FTE';
            const timeframeName = timeScale.charAt(0).toUpperCase() + timeScale.slice(1);
            let title;
            if (period === 'all') {
                title = `Average ${timeframeName} ${metricName} by Employee`;
            } else {
                title = `${timeframeName} ${metricName} (${period}) by Employee`;
            }
            // Build the chart manually using the dashboardEmployees array.  This
            // avoids relying on createBarChart(), which is scoped inside
            // setupDashboard() and therefore not accessible here.  Each chart
            // shows bars proportional to the maximum value with labels and
            // formatted data values (hours with 2 decimals, FTE with 3).
            const chartDiv = document.createElement('div');
            chartDiv.className = 'custom-bar-chart';
            // Title element
            const header = document.createElement('h4');
            header.textContent = title;
            chartDiv.appendChild(header);
            // For each employee, create a row with label and bar
            dashboardEmployees.forEach((emp, index) => {
                const value = values[index];
                const percentage = maxValue > 0 ? (value / maxValue) * 100 : 0;
                const row = document.createElement('div');
                row.className = 'bar-row';
                // Employee name label
                const label = document.createElement('div');
                label.className = 'bar-label';
                label.textContent = emp.name;
                row.appendChild(label);
                // Bar element
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.width = percentage + '%';
                // Determine number formatting based on unit
                const formattedValue = (unit === 'hours') ? value.toFixed(2) : value.toFixed(3);
                bar.setAttribute('data-value', `${formattedValue}`);
                row.appendChild(bar);
                chartDiv.appendChild(row);
            });
            container.appendChild(chartDiv);
        }
    </script>
</body>
</html>